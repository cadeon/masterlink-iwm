ALTER TABLE ORGANIZATION ADD PARENT_ID NUMBER;
ALTER TABLE ORGANIZATION ADD SCHEMA_ID NUMBER;  // NEEDS fk
INSERT INTO SCHEMA_REF ( ID, DESCRIPTION, SCHEMA_TYPE, CODE, PARENT, DISP_ORD ) VALUES (20,'Department','O', 'Department',NULL, 20);
INSERT INTO SCHEMA_REF ( ID, DESCRIPTION, SCHEMA_TYPE, CODE, PARENT, DISP_ORD ) VALUES (21,'Division','O', 'Division',20, 22);
INSERT INTO SCHEMA_REF ( ID, DESCRIPTION, SCHEMA_TYPE, CODE, PARENT, DISP_ORD ) VALUES (22,'Group','O', 'Group',21, 24);
INSERT INTO SCHEMA_REF ( ID, DESCRIPTION, SCHEMA_TYPE, CODE, PARENT, DISP_ORD ) VALUES (23,'Team','O', 'Team',22, 26);
//init organizations
UPDATE ORGANIZATION SET SCHEMA_ID=20

// job total time
ALTER TABLE JOB_TASK  ADD TOTAL_TIME NUMBER;
UPDATE JOB_TASK JT SET TOTAL_TIME = (SELECT  SUM(JTT.TIME) FROM JOB_TASK_TIME JTT WHERE JTT.JOB_TASK_ID=JT.ID GROUP BY JTT.JOB_TASK_ID);

DELETE FROM SKILL_LEVEL_REF WHERE CODE='0'; //have not run this one , due to the mutating trigger


create or replace
FUNCTION Get_Organization_Hierarchy
(orgId IN NUMBER)
RETURN VARCHAR2
IS
	  hierarchy VARCHAR2(200);
          separator VARCHAR(1);

	  CURSOR c1 IS SELECT P.NAME FROM ORGANIZATION O,PARTY P WHERE P.ID=O.PARTY_ID START WITH O.ID=orgId CONNECT BY PRIOR O.PARENT_ID=O.ID;
BEGIN
          separator:='.';
	  FOR myrecord IN c1
	  LOOP     hierarchy := myrecord.NAME || separator || hierarchy;
          separator:='|';
	  END LOOP;
	  RETURN hierarchy;
END;

ALTER TABLE OBJECT_DATA ADD IS_EDIT_IN_FIELD NUMBER(1);
ALTER TABLE OBJECT_DATA_DEF ADD IS_EDIT_IN_FIELD NUMBER(1);

/* cleanup task_def table to remove START_DATE,END_DATE AND RUN_HOURS_THRESHOLD columns. They are not used

CREATE TABLE PROJECT_STATUS_REF(
  ID           NUMBER                           NOT NULL,
  DESCRIPTION  VARCHAR2(50 BYTE)                DEFAULT '-'    NOT NULL,
  DISP_ORD     NUMBER(2),
  CODE         VARCHAR2(20 BYTE)                NOT NULL
);
ALTER TABLE PROJECT_STATUS_REF ADD (CONSTRAINT PK_PROJECTSTATUSREF_ID PRIMARY KEY (ID));
INSERT INTO PROJECT_STATUS_REF ( ID, DESCRIPTION, CODE, DISP_ORD ) VALUES (1,'Preparing','Preparing',10);
INSERT INTO PROJECT_STATUS_REF ( ID, DESCRIPTION, CODE, DISP_ORD ) VALUES (2,'Started','Started',20);
INSERT INTO PROJECT_STATUS_REF ( ID, DESCRIPTION, CODE, DISP_ORD ) VALUES (3,'Cancelled','Cancelled',30);
INSERT INTO PROJECT_STATUS_REF ( ID, DESCRIPTION, CODE, DISP_ORD ) VALUES (4,'Completed','Completed',40);

ALTER TABLE PROJECT  ADD STATUS_ID NUMBER;
ALTER TABLE PROJECT  ADD STARTED_DATE DATE;
ALTER TABLE PROJECT  ADD DESCRIPTION VARCHAR(200);
alter table PROJECT add constraint FK_PROJECT_STATUSID
foreign key (STATUS_ID ) references PROJECT_STATUS_REF (ID)
on delete cascade;


/** not used
CREATE TABLE PROJECT_FREQUENCY_REF(
  ID           NUMBER                           NOT NULL,
  DESCRIPTION  VARCHAR2(50 BYTE)                DEFAULT '-'    NOT NULL,
  DISP_ORD     NUMBER(2),
  VALUE        NUMBER(2),
  LABEL        VARCHAR2(20 BYTE)                NOT NULL,
  CODE         VARCHAR2(20 BYTE)                NOT NULL
);
ALTER TABLE PROJECT_FREQUENCY_REF ADD (CONSTRAINT PK_PROJECTFREQUENCYREF_ID PRIMARY KEY (ID));
INSERT INTO PROJECT_FREQUENCY_REF ( ID, CODE, LABEL, DESCRIPTION, DISP_ORD ) VALUES (1,'Daily','Daily','Performed every day', 10 );
INSERT INTO PROJECT_FREQUENCY_REF ( ID, CODE, LABEL, DESCRIPTION, DISP_ORD ) VALUES (2,'Weekly','Weekly','Performed every week', 20 );
INSERT INTO PROJECT_FREQUENCY_REF ( ID, CODE, LABEL, DESCRIPTION, DISP_ORD ) VALUES (3,'BiWeekly','BiWeekly','Performed every other week', 30 );
INSERT INTO PROJECT_FREQUENCY_REF ( ID, CODE, LABEL, DESCRIPTION, DISP_ORD ) VALUES (4,'Monthly','Monthly','Performed every month', 40 );
INSERT INTO PROJECT_FREQUENCY_REF ( ID, CODE, LABEL, DESCRIPTION, DISP_ORD ) VALUES (5,'BiMonthly','BiMonthly','Performed every other month', 50 );
**//


ALTER TABLE SEQUENCE  drop column SEQUENCE_TYPE_ID;
ALTER TABLE SEQUENCE  ADD ARCHIVED_DATE DATE;
ALTER TABLE SEQUENCE  ADD LOCATOR_ID NUMBER;      //todo FK
ALTER TABLE SEQUENCE  ADD FREQUENCY_ID NUMBER;
ALTER TABLE SEQUENCE  ADD FREQUENCY_VALUE NUMBER;
ALTER TABLE SEQUENCE  ADD ORGANIZATION_ID NUMBER;    //todo FK
ALTER TABLE SEQUENCE  ADD ACTIVE NUMBER(1);
ALTER TABLE SEQUENCE  ADD AUTOPLANNING NUMBER(1);
ALTER TABLE SEQUENCE  ADD NAME VARCHAR(50);
ALTER TABLE SEQUENCE  MODIFY DESCRIPTION VARCHAR(250);
UPDATE SEQUENCE  SET ACTIVE=1;               //BACKWARD COMPATIBILITY
UPDATE SEQUENCE  SET AUTOPLANNING=1;         //BACKWARD COMPATIBILITY
DROP TABLE  SEQUENCE_TYPE;
ALTER TABLE SEQUENCE  ADD START_DATE DATE;
ALTER TABLE SEQUENCE  ADD LAST_PLANNED_DATE DATE;
ALTER TABLE SEQUENCE  ADD PROJECT_TYPE_ID NUMBER;       //TODO FK
ALTER TABLE PROJECT   ADD SEQUENCE_ID NUMBER;           //todo FK
alter table PROJECT add constraint FK_PROJECT_SEQUENCEID foreign key (SEQUENCE_ID ) references SEQUENCE (ID) on delete cascade;
alter table SEQUENCE add constraint FK_SEQUENCE_FREQUENCYID foreign key (FREQUENCY_ID ) references TASK_FREQUENCY_REF (ID);

ALTER TABLE JOB_SCHEDULE  drop column WLS_TEMP;
ALTER TABLE JOB_SCHEDULE  ADD CREATED_TIME DATE;
ALTER TABLE JOB_SCHEDULE  ADD USR VARCHAR(50);

CREATE TABLE JOB_SCHEDULE_HIST
(
  WORK_SCHEDULE_ID  NUMBER,
  ID                NUMBER,
  JOB_ID            NUMBER,
  CREATED_TIME      DATE,
  ACTION_DATE          DATE,
  ACTION            VARCHAR2(1 BYTE),
  USR               VARCHAR2(50 BYTE)
)

create or replace TRIGGER DLT_JOB_SCHEDULE
  AFTER DELETE
     on JOB_SCHEDULE
 REFERENCING NEW AS NEW OLD AS OLD
  FOR EACH ROW
BEGIN
insert into job_schedule_hist (WORK_SCHEDULE_ID,ID,JOB_ID, CREATED_TIME, ACTION_DATE, ACTION,  USR)
values (:OLD.WORK_SCHEDULE_ID, :OLD.ID, :OLD.JOB_ID, :OLD.CREATED_TIME, SYSDATE, 'D',  :OLD.USR)
;
 END;
/

ALTER TABLE JOB_SCHEDULE  ADD DELETED_TIME DATE;

ALTER TABLE JOB_ACTION  ADD MODIFIER VARCHAR2(150 BYTE);
ALTER TABLE JOB_ACTION  ADD VERB VARCHAR2(150 BYTE);
ALTER TABLE JOB_ACTION  ADD NAME VARCHAR2(150 BYTE);
ALTER TABLE JOB_ACTION  ADD SEQUENCE NUMBER;

UPDATE JOB_ACTION JA
SET (NAME,VERB,MODIFIER,SEQUENCE) = (
  SELECT A.NAME,A.VERB,A.MODIFIER,A.SEQUENCE
  FROM ACTION A
  WHERE A.ID = JA.ACTION_ID);




ALTER TABLE JOB_TASK ADD SKILL_TYPE_ID NUMBER;
ALTER TABLE JOB_TASK ADD PRIORITY_ID NUMBER;
ALTER TABLE JOB_TASK  ADD TASK_TYPE_ID NUMBER;
ALTER TABLE JOB_TASK  ADD NUMBER_WORKERS NUMBER;
ALTER TABLE JOB_TASK  ADD ESTIMATED_TIME NUMBER;
ALTER TABLE JOB_TASK  ADD SKILL_LEVEL_ID NUMBER;
ALTER TABLE JOB_TASK ADD  DESCRIPTION VARCHAR2(150 BYTE);

UPDATE JOB_TASK JA SET (SKILL_TYPE_ID,PRIORITY_ID,TASK_TYPE_ID,NUMBER_WORKERS,ESTIMATED_TIME,SKILL_LEVEL_ID,DESCRIPTION) =
(SELECT A.SKILL_TYPE_ID,A.PRIORITY_ID,A.TASK_TYPE_ID,A.NUMBER_WORKERS,A.ESTIMATED_TIME,A.SKILL_LEVEL_ID,A.DESCRIPTION
 FROM TASK A  WHERE A.ID = JA.TASK_ID);

ALTER TABLE PERSON  ADD TITLE VARCHAR(150);


//irina todo: need FKs to ref tables.


//Not in code
UPDATE SCHEDULE_RESPONSIBILITY_REF SET disp_ord=1 WHERE code = 'System';
UPDATE SCHEDULE_RESPONSIBILITY_REF SET disp_ord=2 WHERE code = 'Manual';



//indexes. not yet created but need be considered
CREATE INDEX TASK_TASKDEFID_IDX ON TASK (TASK_DEF_ID)




The above was delivered to Irina in May
ALTER TABLE LOCATOR  ADD TOP_PARENT_ID NUMBER;

create or replace FUNCTION GET_LOCATOR_LOCATION
( locatorId IN NUMBER) RETURN NUMBER
IS
  top_parent_id NUMBER;
  CURSOR c1 IS select id  from locator start with id = locatorId connect by prior parent_id = ID;

BEGIN
	  FOR myrecord IN c1
	  LOOP     top_parent_id := myrecord.ID;
	  END LOOP;
          RETURN top_parent_id;
END GET_LOCATOR_LOCATION;

//UPDATE LOCATOR SET (TOP_PARENT_ID)=(SELECT get_locator_location(ID) FROM DUAL);

create or replace FUNCTION GET_CLASS_HIERARCHY
(classId IN NUMBER)
RETURN VARCHAR2
IS
	  hierarchy VARCHAR2(200);
          separator VARCHAR(1);
	  CURSOR c1 IS SELECT OC.CODE FROM OBJECT_CLASSIFICATION OC START WITH OC.ID=classId CONNECT BY PRIOR OC.PARENT_ID=OC.ID;
BEGIN
          separator:='';
	  FOR myrecord IN c1
	  LOOP     hierarchy := myrecord.CODE || separator || hierarchy;
          separator:='.';
	  END LOOP;
	  RETURN hierarchy;
END GET_CLASS_HIERARCHY;


ALTER TABLE OBJECT  ADD ORGANIZATION_ID NUMBER

CREATE TABLE ATTACHMENT (
  ID  NUMBER (38)   NOT NULL,
  FILE_NME  VARCHAR2 (30),
  DESCRIPTION  VARCHAR2 (200),
  MIME_TYP  VARCHAR2 (30),
  BIN_DATA  BLOB,
  CREATED_DT   DATE,
  CONSTRAINT ATTACHMENT_PK
  PRIMARY KEY ( ID ) ) ;


create or replace
TRIGGER INS_ATTACHMENT
  BEFORE INSERT
     on ATTACHMENT
 REFERENCING NEW AS NEW OLD AS OLD
  FOR EACH ROW
BEGIN
  /--SELECT  (NVL(MAX(ID),0)+1) INTO :NEW.ID FROM ATTACHMENT;--/
  SELECT  SYSDATE INTO :NEW.CREATED_DATE FROM ATTACHMENT;
END;

CREATE SEQUENCE ATTACHMENT_SEQ  START WITH  1000 INCREMENT BY  1







